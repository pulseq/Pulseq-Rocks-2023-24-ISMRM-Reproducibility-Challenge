clear; close all; clc;
% This is an experimental high-performance 2D slice-selective EPI sequence
% for the "Pulseq Rocks" team in the 2023-24 ISMRM Reproducibility Team Challenge.

% It uses split gradients to overlap blips with the readout
% gradients combined with ramp-samping. It also employs an 3-echo navigator for ghost correction.
% This sequence strongly leans towards the Siemens' ep2d_bold product sequence
% especially in terms of flags and labels to enable ICE online reconstruction.

% Author: Qingping Chen (qingping.chen@uniklinik-freiburg.de)
% Institution: Division of Medical Physics, Department of Radiology,
% University Medical Center Freiburg
% Date: 11 Dec. 2024

% 2025.06.13
% the minimal interval between two ADCs in UIH is 70 us. (ADC-ADC deadtime)
% The minimal interval between the two adjacent RFs is 400 us. (RF-RF deadtime)
% the minimal interval between RF and ADC is 10 us (RF-ADC deadtime)
% the minimal interval between ADC and RF is the maximal value of RF-RF
% deadtime and ADC-ADC dead time (ADC-RF deadtime)

% 2025.08.22
% the generated .seq file is the same as the one generated by Jon's script
% for the GE platform.
% the generated .seq file is the same as the one for Boston's data.

% 2025.09.14
% the generated .seq file is now the same as the one sent by Thomas for Philips scans.


% Set system limits

% select your vendor
% vendor = 'ge' ;
vendor = 'siemens' ;
% vendor = 'uih' ;
% vendor = 'philips' ;
sys = mr.opts('MaxGrad',32, 'GradUnit','mT/m',...
    'MaxSlew',130, 'SlewUnit','T/m/s',...
    'rfRingdownTime', 30e-6, 'rfDeadtime', 100e-6,...
    'adcDeadTime', 10e-6, 'B0', 2.89 ... % this is Siemens' 3T
    ) ;
% set your B0 field strength for fat suppression
switch vendor(1)
    case 's' % Siemens @Freiburg, Germany and @Boston, US
        sys.B0 = 2.89 ; % real B0 field strength of Siemens 3T scanner
    case 'g' % GE @Michigan, US
        sys.B0 = 3 ;
        sys.rfRingdownTime = 60e-6 ;
        sys.gradRasterTime = 4e-6 ;
        sys.rfRasterTime = 4e-6 ;
        sys.blockDurationRaster = 4e-6 ;
        sys.adcDeadTime = 0e-6 ;
        sys.adcRasterTime = 2e-6 ;
    case 'u' % United imaging @Shanghai, China
        sys.B0 = 3 ;
    case 'p' % Philips @Utrecht, Netherlands
        sys.B0 = 7.0 ; % 7.0 3.0 
    otherwise
        error('Please enter the correct vendor name!') ;
end
seq = mr.Sequence(sys) ;      % Create a new sequence object
fov = 220e-3 ; Nx = 80 ; Ny = Nx ;  % Define FOV and resolution
thickness = 3e-3 ;            % slice thinckness in mm
sliceGap = 0 ;             % slice gap im mm
Nslices = 48 ;
Nrep = 30 ; % multiple repetitions for the equilibrium status to reach: 30
TR = 3500e-3 ;

pe_enable = 1 ;               % a flag to quickly disable phase encoding (1/0) as needed for the delay calibration
ro_os = 2 ;                   % oversampling factor
if vendor(1) == 'u' % the UIH system forces an os factor of 2 automatically. so set ro_os to 1 here. For recon, set it back to 2 for the .seq file
    ro_os = 1 ;
end
readoutTime = 640e-6 ; % This is the ADC duration [s]

readoutBW = 1/readoutTime ; % readout bandwidth
disp(['Readout bandwidth = ', num2str(readoutBW), ' Hz/Px']) ;
partFourierFactor = 1 ;       % partial Fourier factor: full sampling: 1. start with ky=0
Nnav = 3 ;		   % number of navigator echoes for ghost supprerssion

% Create fat-sat pulse
sat_ppm = -3.3 ; % frequency offset is -407 Hz in Siemens product sequence
sat_freq=sat_ppm*1e-6*sys.B0*sys.gamma ; % gamma: [Hz/T]
if vendor(1) ~= 'g'
    rf_fs = mr.makeGaussPulse(110*pi/180,'system',sys,'Duration',5120e-6,'dwell',10e-6,...
        'bandwidth',abs(sat_freq),'freqOffset',sat_freq,'use','saturation');
else
    rf_fs = mr.makeGaussPulse(110*pi/180,'system',sys,'Duration',5000e-6,'dwell',sys.rfRasterTime,...
        'bandwidth',abs(sat_freq),'freqOffset',sat_freq,'use','saturation');
end
rf_fs.phaseOffset=-2*pi*rf_fs.freqOffset*mr.calcRfCenter(rf_fs) ; % compensate for the frequency-offset induced phase

% A pair of spoilers (in x-, y-, z-axises) before and after the fatSat pulse
% to eliminate stimulated echoes.
spoiler_amp_crush = 3 * 8 * 1e-3 *sys.gamma ; % fatSat gradient spoiler amplitude [mT/m] -> [Hz/m]
rise_time_crush = 500e-6 ; % [s], ramp up and ramp down time
flat_time_crush = 2500e-6 ; % [s], flattop time
gx_crush_pre = mr.makeTrapezoid('x','amplitude', spoiler_amp_crush,'riseTime',rise_time_crush,'flatTime',flat_time_crush,'system',sys) ;
gy_crush_pre = mr.makeTrapezoid('y','amplitude', -spoiler_amp_crush,'riseTime',rise_time_crush,'flatTime',flat_time_crush,'system',sys) ;
gz_crush_pre = mr.makeTrapezoid('z','amplitude', spoiler_amp_crush,'riseTime',rise_time_crush,'flatTime',flat_time_crush,'system',sys) ;
gx_crush_post = mr.scaleGrad(gx_crush_pre, -1) ;
gy_crush_post = mr.scaleGrad(gy_crush_pre, -1) ;
gz_crush_post = mr.scaleGrad(gz_crush_pre, -1) ;

% Create 90-degree slice-selective pulse and gradient
sth_ex = 1 ; % correction factors RF. Note: Trio, Prisma, and Cima.X in Freiburg use slice profile-corrected factor, but it is very close to 1.
[rf, gz, gzReph] = mr.makeSincPulse(pi/2,'system',sys,'Duration',2e-3,...
    'SliceThickness',thickness*sth_ex,'apodization',0.42,'timeBwProduct',4,'use','excitation');
gamma_H1 = sys.gamma * 1e-6 ; % [Hz/T] -> [MHz/T]
rf_fs_peak = max(abs(rf_fs.signal))/gamma_H1 ; % [uT]
rf_peak = max(abs(rf.signal))/gamma_H1 ; % [uT]
disp(['The peak rf_fs amplitude = ', num2str(rf_fs_peak), ' uT']) ;
disp(['The peak rf amplitude = ', num2str(rf_peak), ' uT']) ;

% check RF profile alighnment
% [M_z90,M_xy90,F2_90] = mr.simRf(rf) ;
% sl_th_90 = mr.aux.findFlank(F2_90(end:-1:1)/gz.amplitude,abs(M_xy90(end:-1:1)),0.5)-mr.aux.findFlank(F2_90/gz.amplitude,abs(M_xy90),0.5);
% figure; plot(F2_90/gz.amplitude*1000,abs(M_xy90)); title('RF profiles'); xlabel('through-slice pos, mm');
% fprintf('slice thicknes 90-degree excitation pulse: %.3f mm\n',sl_th_90*1e3);

% define the output trigger to play out with every slice excitatuion
trig = mr.makeDigitalOutputPulse('osc0','duration', 100e-6); % possible channels: 'osc0','osc1','ext1'

% Define other gradients and ADC events
deltak = 1/fov ;
kWidth = Nx*deltak ;

% Phase blip in shortest possible time
blip_dur = ceil(2*sqrt(deltak/sys.maxSlew)/10e-6/2)*10e-6*2; % we round-up the duration to 2x the gradient raster time
if vendor(1) == 'u'
    blip_dur = ceil(max(2*sqrt(deltak/sys.maxSlew), 70e-6)/10e-6/2)*10e-6*2; % QC: the ADC dead time for UIH: 70e-6 us
end
gy = mr.makeTrapezoid('y',sys,'Area',-deltak,'Duration',blip_dur); % we use negative blips to save one k-space line on our way towards the k-space center

% readout gradient is a truncated trapezoid with dead times at the beginnig
% and at the end each equal to a half of blip_dur
% the area between the blips should be defined by kWidth
% we do a two-step calculation: we first increase the area assuming maximum
% slewrate and then scale down the amplitude to fix the area
extra_area = blip_dur/2*blip_dur/2*sys.maxSlew ; % check unit!;
gx = mr.makeTrapezoid('x',sys,'Area',kWidth+extra_area,'duration',readoutTime+blip_dur) ;
% actual sampled area = whole area - rampup deadarea - rampdown deadarea
actual_area = gx.area - gx.amplitude/gx.riseTime*blip_dur/2*blip_dur/2/2 - gx.amplitude/gx.fallTime*blip_dur/2*blip_dur/2/2 ;
gx.amplitude = gx.amplitude/actual_area*kWidth ; % rescale amplitude to make sampled area = kWidth
gx.area = gx.amplitude*(gx.flatTime + gx.riseTime/2 + gx.fallTime/2) ; % udpate parameters relative to amplitude
gx.flatArea = gx.amplitude*gx.flatTime ;
assert(gx.amplitude<=sys.maxGrad) ;
ESP = 1e3 * mr.calcDuration(gx) ; % echo spacing, ms
disp(['echo spacing = ', num2str(ESP), ' ms']) ;
% calculate ADC
% assert(ro_os>=2) ;
adcSamples = Nx*ro_os ;
assert(mod(adcSamples, 4)==0) ; % on Siemens the number of ADC samples need to be divisible by 4
adcDwell=floor(readoutTime/adcSamples*1e7)*1e-7 ; % % round-down dwell time to 100 ns
disp(['ADC bandwidth = ', num2str(1/adcDwell/1000), ' kHz']) ;
fprintf('Actual RO oversampling factor is %g, Siemens recommends it to be above 1.3\n', deltak/gx.amplitude/adcDwell)
adc = mr.makeAdc(adcSamples,'Dwell',adcDwell,'Delay',blip_dur/2);
disp(['ADC dwell time = ', num2str(adc.dwell*1e6), ' us']) ;
% realign the ADC with respect to the gradient
time_to_center = adc.dwell*((adcSamples-1)/2+0.5) ; % I've been told that Siemens samples in the center of the dwell period
if vendor(1) ~= 'g'
    adc.delay = round((gx.riseTime+gx.flatTime/2-time_to_center)*1e6)*1e-6 ; % we adjust the delay to align the trajectory with the gradient. We have to aligh the delay to 1us
else
    adc.delay = round((gx.riseTime+gx.flatTime/2-time_to_center)/4*1e6)*4*1e-6 ;
end
% this rounding actually makes the sampling points on odd and even readouts
% to appear misalligned. However, on the real hardware this misalignment is
% much stronger anyways due to the grdient delays

% split the blip into two halves and produce a combined synthetic gradient
gy_parts = mr.splitGradientAt(gy, blip_dur/2, sys) ;
[gy_blipup, gy_blipdown,~] = mr.align('right',gy_parts(1),'left',gy_parts(2),gx) ;
gy_blipdownup=mr.addGradients({gy_blipdown, gy_blipup}, sys) ;

% pe_enable support
gy_blipup.waveform=gy_blipup.waveform*pe_enable ;
gy_blipdown.waveform=gy_blipdown.waveform*pe_enable ;
gy_blipdownup.waveform=gy_blipdownup.waveform*pe_enable;

% phase encoding and partial Fourier
Ny_pre = round(partFourierFactor*Ny/2-1) ; % PE steps prior to ky=0, excluding the central line
Ny_post = round(Ny/2+1) ; % PE lines after the k-space center including the central line
Ny_meas = Ny_pre+Ny_post ;

% Pre-phasing gradients
gxPre = mr.makeTrapezoid('x',sys,'Area',-gx.area/2) ; % Thomas: Iew, larger ampl than gx!?
gyPre = mr.makeTrapezoid('y',sys,'Area',Ny_pre*deltak) ;
[gxPre,gyPre,gzReph]=mr.align('right',gxPre,'left',gyPre,gzReph) ;
% relax the PE prepahser to reduce stimulation
gyPre = mr.makeTrapezoid('y',sys,'Area',gyPre.area,'Duration',mr.calcDuration(gxPre,gyPre,gzReph)) ;
gyPre.amplitude=gyPre.amplitude*pe_enable ;

spoilDur = 2e-3 ;
spAx = 2000 ;
spAz = 2000 ;
gxSpoil = mr.makeTrapezoid('x','Area', spAx, 'Duration', spoilDur,'system', sys) ;
gzSpoil = mr.makeTrapezoid('z','Area', spAz, 'Duration', spoilDur,'system', sys) ;
gyPost_area = gyPre.area + (gy_blipup.area + gy_blipdown.area ) + gy_blipdownup.area * (Ny_meas-2) ;
gyPost = mr.makeTrapezoid('y', sys, 'Area', -gyPost_area, 'Duration', spoilDur) ;

% slice positions
slicePositions = (thickness+sliceGap)*((0:(Nslices-1)) - (Nslices-1)/2) ;
slicePositions = slicePositions([1:2:Nslices 2:2:Nslices]); % reorder slices for an interleaved acquisition

% Define sequence blocks
TR_1slice = mr.calcDuration(gx_crush_pre, gy_crush_pre, gz_crush_pre) + mr.calcDuration(rf_fs)...
    + mr.calcDuration(gx_crush_post, gy_crush_post, gz_crush_post)...
    + mr.calcDuration(gz) + mr.calcDuration(gzReph)+...
    Nnav*mr.calcDuration(gx) + mr.calcDuration(gyPre) + ...
    Ny_meas*mr.calcDuration(gx) + mr.calcDuration(gxSpoil, gyPost, gzSpoil) ;

TRdelay = TR - TR_1slice * Nslices ;
TRdelay_perSlice = ceil(TRdelay / Nslices / sys.blockDurationRaster) * sys.blockDurationRaster ;
% assert(TRdelay_perSlice>=0 ) ;

TE = rf.shape_dur/2 + rf.ringdownTime + mr.calcDuration(gzReph)+...
    Nnav*mr.calcDuration(gx) + mr.calcDuration(gyPre) + ...
    Ny_meas/2*mr.calcDuration(gx) - mr.calcDuration(gx)/2 ;
disp(['TR = ', num2str(1000*TR), ' ms', ', TE = ', num2str(1000*TE), ' ms']) ;

% change orientation to match the product sequence
switch vendor(1)
    case 's' % Siemens
        % reverse the polarity of all gradients in readout direction (Gx)
        gxPre = mr.scaleGrad(gxPre, -1) ;
        gx = mr.scaleGrad(gx, -1) ;
        gxSpoil = mr.scaleGrad(gxSpoil, -1) ;
    case 'p' % Philips: flip readout direction.
        % not to reverse the polarity of all gradients in readout direction (Gx)
        % gxPre = mr.scaleGrad(gxPre, -1) ;
        % gx = mr.scaleGrad(gx, -1) ;
        % gxSpoil = mr.scaleGrad(gxSpoil, -1) ;
    case 'u' % UIH
        % reverse the polarity of all gradients in readout direction (Gx)
        gxPre = mr.scaleGrad(gxPre, -1) ;
        gx = mr.scaleGrad(gx, -1) ;
        gxSpoil = mr.scaleGrad(gxSpoil, -1) ;
        % reverse the polarity of all gradients in PE direction (Gy)
        gyPre = mr.scaleGrad(gyPre, -1) ;
        gy_blipup = mr.scaleGrad(gy_blipup, -1) ;
        gy_blipdown = mr.scaleGrad(gy_blipdown, -1) ;
        gy_blipdownup = mr.scaleGrad(gy_blipdownup, -1) ;
        gyPost = mr.scaleGrad(gyPost, -1) ;
    case 'g' % GE
        gyPre = mr.scaleGrad(gyPre, -1) ;
        gy_blipup = mr.scaleGrad(gy_blipup, -1) ;
        gy_blipdown = mr.scaleGrad(gy_blipdown, -1) ;
        gy_blipdownup = mr.scaleGrad(gy_blipdownup, -1) ;
        gyPost = mr.scaleGrad(gyPost, -1) ;
end

% record initial readout gradient polarity
ROpolarity = sign(gx.amplitude) ;

for r=1:Nrep
disp(['current repetition = ', num2str(r), '/', num2str(Nrep)]) ;
if vendor(1) ~= 'g'
    seq.addBlock(mr.makeLabel('SET', 'SLC', 0) ) ;
end
    for s=1:Nslices
        if vendor(1) ~= 'g'
            seq.addBlock(gx_crush_pre, gy_crush_pre, gz_crush_pre) ;
            seq.addBlock(rf_fs) ;
        else
            seq.addBlock(gx_crush_pre, gy_crush_pre, gz_crush_pre, mr.makeLabel('SET', 'TRID', 1)) ;
            seq.addBlock(rf_fs, mr.makeDelay(10e-6)) ;
        end
        seq.addBlock(gx_crush_post, gy_crush_post, gz_crush_post) ;
        rf.freqOffset = gz.amplitude*slicePositions(s) ;
        if vendor(1) == 'g' % NOPE! Not for Philips!! || vendor(1) == 'p' % flip slice order for GE and Philips
            rf.freqOffset = -rf.freqOffset ;
        end
        rf.phaseOffset = -2*pi*rf.freqOffset*mr.calcRfCenter(rf) ; % compensate for the slice-offset induced phase
        seq.addBlock(rf, gz, trig) ;
        if Nnav>0
            gxPre = mr.scaleGrad(gxPre, -1) ; % reverse the readout gradient in advance for navigator
            gx = mr.scaleGrad(gx, -1) ; % reverse the readout gradient in advance for navigator
            seq.addBlock(gxPre,gzReph, ...
                mr.makeLabel('SET','NAV',1),...
                mr.makeLabel('SET','LIN', floor(Ny/2))) ; % k-space center line
            gxPre = mr.scaleGrad(gxPre, -1) ; % reverse the gxPre back after addBlock
            for n=1:Nnav
                seq.addBlock(mr.makeLabel('SET','REV', sign(gx.amplitude) ~= ROpolarity ), ...
                    mr.makeLabel('SET','SEG', sign(gx.amplitude) ~= ROpolarity ), ...
                    mr.makeLabel('SET','AVG', n==Nnav ) ) ;
                seq.addBlock(gx, adc);
                gx = mr.scaleGrad(gx, -1) ;   % Reverse polarity of read gradient for the next navigator echo
            end
            seq.addBlock(gyPre,  ...
                mr.makeLabel('SET','LIN', -1), ... % increment LIN by -1 for "llin" performs before adc below
                mr.makeLabel('SET','NAV', 0), ...
                mr.makeLabel('SET','AVG', 0) );% lin/nav/avg reset
        else
            seq.addBlock(gxPre,gyPre,gzReph,...
                mr.makeLabel('SET','LIN', -1), ...
                mr.makeLabel('SET','NAV', 0), ...
                mr.makeLabel('SET','AVG', 0) );% lin/nav/avg reset
        end

        for i = 1:Ny_meas
            lrev = mr.makeLabel('SET', 'REV', sign(gx.amplitude) ~= ROpolarity ) ;
            lseg = mr.makeLabel('SET', 'SEG', sign(gx.amplitude) ~= ROpolarity ) ;
            llin = mr.makeLabel('INC', 'LIN', 1) ;
            if i==1 % first phase encoding step
                seq.addBlock(gx, gy_blipup, adc, lrev, lseg, llin) ; % Read the first line of k-space with a single half-blip at the end
            elseif i==Ny_meas % last phase encoding step
                seq.addBlock(gx, gy_blipdown, adc, lrev, lseg, llin) ; % Read the last line of k-space with a single half-blip at the beginning
            else % phase encoding steps in between
                seq.addBlock(gx, gy_blipdownup, adc, lrev, lseg, llin) ; % Read an intermediate line of k-space with a half-blip at the beginning and a half-blip at the end
            end
            gx = mr.scaleGrad(gx, -1) ;   % Reverse polarity of read gradient
        end
        seq.addBlock(mr.makeLabel('INC','SLC', 1)) ;
        if sign(gx.amplitude) ~= ROpolarity % if the polarity of gx is not the same as original one
            gx = mr.scaleGrad(gx, -1) ;
        end
        seq.addBlock(gxSpoil, gyPost, gzSpoil) ;
        % seq.addBlock(mr.makeDelay(TRdelay_perSlice)) ; % use the minimal TR
    end
    if vendor(1) ~= 'g'
        seq.addBlock(mr.makeLabel('INC','REP', 1)) ;
    end
end

%% check whether the timing of the sequence is correct
[ok, error_report]=seq.checkTiming ;

if (ok)
    fprintf('Timing check passed successfully\n') ;
else
    fprintf('Timing check failed! Error listing follows:\n') ;
    fprintf([error_report{:}]);
    fprintf('\n');
end

%% do some visualizations

seq.plot('timeDisp','us','showBlocks',1,'timeRange',[0 25e-3], 'stacked', 1) ; %detailed view

rf.freqOffset=0;
rf.phaseOffset=0;
[rf_bw,rf_f0,rf_spectrum,rf_w]=mr.calcRfBandwidth(rf);
figure;plot(rf_w,abs(rf_spectrum));
title('Excitation pulse profile (low-angle approximation)');
xlabel('Frequency, Hz');
xlim(3*[-rf_bw rf_bw]);

%% trajectory calculation
[ktraj_adc, t_adc, ktraj, t_ktraj, t_excitation, t_refocusing, slicepos, t_slicepos] = seq.calculateKspacePP();

% plot k-spaces
figure; plot(t_ktraj, ktraj'); % plot the entire k-space trajectory
hold on; plot(t_adc,ktraj_adc(1,:),'.'); % and sampling points on the kx-axis
title('k-space vector components as functions of time');

figure; plot(ktraj(1,:),ktraj(2,:),'b'); % a 2D plot
hold on;plot(ktraj_adc(1,:),ktraj_adc(2,:),'r.'); % plot the sampling points
axis('equal'); % enforce aspect ratio for the correct trajectory display
title('k-space trajectory (k_x/k_y)');

figure; plot(t_slicepos, slicepos, '*');
title('slice position (vector components) as a function or time');
%axis off;

%% prepare the sequence output for the scanner
seq.setDefinition('Name', 'epi');
seq.setDefinition('FOV', [fov fov max(slicePositions)-min(slicePositions)+thickness]);
% the following definitions have effect in conjunction with LABELs
seq.setDefinition('SlicePositions', slicePositions);
seq.setDefinition('SliceThickness', thickness);
seq.setDefinition('SliceGap', sliceGap);
seq.setDefinition('ReceiverGainHigh',1) ;
seq.setDefinition('ReadoutOversamplingFactor', ro_os) ;
seq.setDefinition('TargetGriddedSamples', Nx*ro_os) ; % number of samples after gridding (with oversamping)
% readout gridding parameters
seq.setDefinition('TrapezoidGriddingParameters', [gx.riseTime gx.flatTime gx.fallTime adc.delay-gx.delay adc.numSamples*adc.dwell]); % rise,flat,fall,adc_delay,adc_dur
seq.write('epi_challenge.seq') ;

%% evaluate label settings
adc_lbl = seq.evalLabels('evolution','adc') ;
figure; plot(adc_lbl.SLC) ;
hold on; plot(adc_lbl.LIN) ;
if vendor(1) ~= 'g'
    plot(adc_lbl.SEG); plot(adc_lbl.AVG); plot(adc_lbl.REP);
end
legend('slc','lin','seg','avg','rep');
title('evolution of labels/counters');

return ;

%% another pretty plot option e.g. for publications

seq.paperPlot('blockRange',[1 95],'lineWidth',6) ;
set(gcf, 'Position', get(0, 'Screensize'));
exportgraphics(gcf,'epi_paperplot.png',...
    'ContentType', 'vector',...
    'BackgroundColor','none') ;

%% another manual pretty plot option for gradients

lw=1;
%gw=seq.gradient_waveforms();
wave_data=seq.waveforms_and_times(true); % also export RF
gwm=max(abs([wave_data{1:3}]'));
rfm=max(abs([wave_data{4}]'));
ofs=2.05*gwm(2);

% plot "axes"
figure;
axis_clr=[0.5,0.5,0.5];
plot([-0.01*gwm(1),1.01*gwm(1)],[0 0]*ofs,'Color',axis_clr,'LineWidth',lw/5); hold on;
plot([-0.01*gwm(1),1.01*gwm(1)],[1 1]*ofs,'Color',axis_clr,'LineWidth',lw/5);
plot([-0.01*gwm(1),1.01*gwm(1)],[2 2]*ofs,'Color',axis_clr,'LineWidth',lw/5);
plot([-0.01*gwm(1),1.01*gwm(1)],[3 3]*ofs,'Color',axis_clr,'LineWidth',lw/5);

% plot the RF waveform
plot(wave_data{4}(1,:), abs(wave_data{4}(2,:))/rfm(2)*gwm(2)*0.75+3*ofs,'k','LineWidth',lw);

% plot the entire gradient waveforms
plot(wave_data{3}(1,:), wave_data{3}(2,:)+2*ofs,'Color',[0,0.5,0.3],'LineWidth',lw);
plot(wave_data{2}(1,:), wave_data{2}(2,:)+1*ofs,'r','LineWidth',lw);
plot(wave_data{1}(1,:), wave_data{1}(2,:),'b','LineWidth',lw);
t_adc_gr=t_adc+0.5*seq.gradRasterTime; % we have to shift the time axis because it is otherwise adpted to the k-space, which is a one-sided integration of the trajectory
gwr_adc=interp1(wave_data{1}(1,:), wave_data{1}(2,:),t_adc_gr);
plot(t_adc_gr,gwr_adc,'b.','MarkerSize',5*lw); % and sampling points on the kx-axis

xlim([-0.03*gwm(1),1.03*gwm(1)]);

set(gca,'xtick',[]);
set(gca,'xticklabel',[]);
set(gca,'ytick',[]);
set(gca,'yticklabel',[]);

%% very optional slow step, but useful for testing during development e.g. for the real TE, TR or for staying within slew rate limits

rep = seq.testReport;
fprintf([rep{:}]);

%% create a smoothly rotating 3D k-space plot
[kfa,ta,kf]=seq.calculateKspacePP();

figure;plot3(kf(1,:),-kf(3,:),kf(2,:));
hold on;plot3(kfa(1,:),-kfa(3,:),kfa(2,:),'r.');
set(gca,'visible','off'); % hide axes
set(gca, 'CameraViewAngle',get(gca, 'CameraViewAngle')); % freeze the view
kabsmax=max(abs(kf)')';
kxyabsmax=max(kabsmax([1 3]));
kxyzabsmax=max(kabsmax);
%axis([-kxyabsmax kxyabsmax -kxyabsmax kxyabsmax -kabsmax(2) kabsmax(2)])
axis(0.01*[-kxyzabsmax kxyzabsmax -kxyzabsmax kxyzabsmax -kxyzabsmax kxyzabsmax])
%s1=1.2;
%axis([ -kabsmax(2)*s1 kabsmax(2)*s1  -kabsmax(2)*s1 kabsmax(2)*s1 min(kf(1,:)) kabsmax(1)]);
[caz,cel] = view;
folder='kspace3d';
mkdir(folder);
for caz_add=0:5:359
    view(caz+caz_add,cel);
    drawnow;
    %print( '-r100', '-dpng', [folder '/frame_' num2str(caz_add,'%03d') '.png']);
    % use convert frame_???.png -gravity center -crop 300x300+0+0 +repage -delay 0.1 -loop 0 kspace_gre3d.gif
    % to create a GIF movie
end
