clear all;close all;clc;
% This is a grappa-accelerated MPRAGE sequence with ICE online reconstruction
% for the "Pulseq Rocks" team in the 2023-24 ISMRM Reproducibility Team Challenge.

% Author: Qingping Chen (qingping.chen@uniklinik-freiburg.de)
% Institution: Division of Medical Physics, Department of Radiology,
% University Medical Center Freiburg
% Date: 11 Dec. 2024

% 2025.08.22
% the generated .seq file is the same as the one for Boston's data.
% the generated .seq file is the same as the one generated by Jon's script
% for the GE platform.

% 2025.09.01
% the generated .seq file is the same as the one for Philips' data.
% However, we need to flip the readout direction and partition encoding
% direction to match the DICOM images.

% set system limits

% select your vendor
% vendor = 'ge' ;
vendor = 'siemens' ;
% vendor = 'uih' ;
% vendor = 'philips' ;
sys = mr.opts('MaxGrad', 24, 'GradUnit', 'mT/m', ...
    'MaxSlew', 100, 'SlewUnit', 'T/m/s', 'rfRingdownTime', 20e-6, ...
    'rfDeadTime', 100e-6, 'adcDeadTime', 10e-6, 'B0', 2.89);

% set your B0 field strength for fat suppression
switch vendor(1)
    case 's' % Siemens @Freiburg, Germany and @Boston, US
        sys.B0 = 2.89 ; % real B0 field strength of Siemens 3T scanner
    case 'g' % GE @Michigan, US
        sys.B0 = 3 ;
        segmentRingdownTime = 116e-6 ;   % gap/dead time after each segment (TRID)
        sys.rfRingdownTime = 60e-6 ;
        sys.gradRasterTime = 4e-6 ;
        sys.rfRasterTime = 4e-6 ;
        sys.blockDurationRaster = 4e-6 ;
        sys.adcRasterTime = 2e-6 ;
        sys.adcDeadTime = 0e-6 ;
    case 'u' % United imaging @Shanghai, China
        sys.B0 = 3 ;
	    sys.rfDeadTime = 200e-6 ;
	    sys.adcDeadTime = 70e-6 ;
    case 'p' % Philips @Utrecht, Netherlands
        sys.B0 = 7 ;
    otherwise
        error('Please enter the correct vendor name!') ;
end

max_B1_GE = 25 ; % the maximum B1 field on GE is 25 uT
seq = mr.Sequence(sys) ;           % Create a new sequence object
alpha = 8 ;                        % flip angle
ro_dur = 5120e-6 ;                 % RO duration
disp(['readout bandwidth = ', num2str(1/ro_dur), ' kHz']) ;
ro_os = 2 ;                        % readout oversampling
if vendor(1) == 'u' % the UIH system forces an os factor of 2 automatically. so set ro_os to 1 here
    ro_os = 1 ;
end
ro_spoil = 3.0 ;                     % additional k-max excursion for RO spoiling
TI = 1.1 ;
TRout = 2.5 ;
% TE & TR in the inner loop are as short as possible derived from the above parameters and the system specs
% more in-depth parameters
rfSpoilingInc = 117 ;              % RF spoiling increment
rfLen = 100e-6 ;
ax = struct ; % encoding axes
% sagittal fov options % remember to enable OrientationMapping SAG in setDefinition section below
fov = [192 240 256]*1e-3 ;         % Define FOV and resolution
N = [192 240 256] ;              % matrix sizes
phaseResoluion = fov(3)/N(3) / (fov(2)/N(2)) ;
% Gx: partition encoding (gpe1, inner loop), Gy: phase encoding (gpe2, outer loop), Gz: readout (gro1)
ax.d1 = 'z' ; % the fastest dimension (readout)
ax.d2 = 'x' ; % the second-fast dimension (the inner pe loop)
%transversal fov options 
%fov=[256 192 240]*1e-3;         % Define FOV and resolution
%N = [256 192 240];               % matrix sizes
%ax.d1='x'; % the fastest dimension (readout)
%ax.d2='z'; % the second-fast dimension (the inner pe loop)

ax.d3 = setdiff('xyz', [ax.d1 ax.d2]) ; % automatically set the slowest dimension
ax.n1 = strfind('xyz', ax.d1) ;
ax.n2 = strfind('xyz', ax.d2) ;
ax.n3 = strfind('xyz', ax.d3) ;

%%
% fat-related parameters at 3T
fat_ppm = -3.3 ; % frequency offset is -407 Hz in Siemens product sequence
fat_freq = fat_ppm*1e-6*sys.B0*sys.gamma ; % gamma: [Hz/T], freq: [Hz]
fat_delay = round(1 / (2 * abs(fat_freq)) / sys.blockDurationRaster) * sys.blockDurationRaster ; % [s] 2*pi*fat_freq * fat_delay = pi

% Create a 1:1 binominal pulse for water-only excitaiton
rf1 = mr.makeBlockPulse(alpha/2*pi/180, sys, 'Duration', rfLen/2, 'use', 'excitation') ; % the first RF pulse
rf2 = mr.makeBlockPulse(alpha/2*pi/180, sys, 'Duration', rfLen/2, 'use', 'excitation') ; % the secnd RF pulse
rf_we = rf1 ;
rf_we.signal = [rf1.signal(:); 0; 0; rf2.signal(:)] ; % combine rf1 and rf2 to be a 1:1 binominal pulse
if vendor(1) == 'g'
    rf_we.t = [rf1.t(:); rf1.t(end)+2*sys.rfRasterTime; rf1.t(end)+fat_delay-2*sys.rfRasterTime; rf1.t(end)+fat_delay+rf2.t(:)] ; % manipulate the timing to align with bloch raster time
    rf_we.shape_dur = rf_we.t(end) ;
    rf_we.delay = sys.rfDeadTime;
    % interpolate to uniform raster
    t = sys.rfRasterTime*[0.5 + 1:length(rf_we.t)] ; % QC: this is wrong! now the WE RF becomes a block RF. 2025.08.22
    rf_we.signal = interp1(rf_we.t,rf_we.signal, t, 'linear', 'extrap') ; % QC: this is wrong! 2025.08.22
    rf_we.signal = rf_we.signal(:).';
    rf_we.t = t ;
else
    rf_we.t = [rf1.t; rf1.t(end)+sys.rfRasterTime; rf1.t(end)+fat_delay-sys.rfRasterTime; rf1.t(end)+fat_delay+rf2.t] ; % manipulate the timing to align with bloch raster time
    rf_we.shape_dur = rf_we.t(end) ;
end

clear rf1 rf2 ; % clear the first and second RF pulses
% inversion pulse
rf180 = mr.makeAdiabaticPulse('hypsec', sys, 'Duration', 10.24e-3, 'dwell', 1e-5, 'use', 'inversion') ;
gamma_H1 = sys.gamma*1e-6 ; % [MHz/T]
rf180_peak = max(abs(rf180.signal))/gamma_H1 ; % [uT]
rf_we_peak = max(abs(rf_we.signal))/gamma_H1 ; % [uT]
if rf180_peak > max_B1_GE
    disp(['The peak rf180 amplitude of ', num2str(rf180_peak), ' uT ', 'violates the max. B1 field of ', num2str(max_B1_GE), ' uT on GE']) ;
    assert(rf180_peak > max_B1_GE) ;
end
if rf_we_peak > max_B1_GE
    disp(['The peak rf_we amplitude of ', num2str(rf_fs_peak), ' uT', 'violates the max. B1 field of ', num2str(max_B1_GE), ' uT on GE']) ;
    assert(rf_we_peak > max_B1_GE) ;
end
% Define other gradients and ADC events
deltak = 1./fov ;
gro = mr.makeTrapezoid(ax.d1,'Amplitude',-N(ax.n1)*deltak(ax.n1)/ro_dur,'FlatTime',ceil(ro_dur/sys.gradRasterTime)*sys.gradRasterTime,'system',sys);
% 2025.07.04, for gro generation in UIH, use (ro_dur+sys.adcDeadTime). because we are not
% allowed to have ADC too close to the block edges. adding sys.adcDeadTime
% to adc.flatTime
% doesn't affect data acquistion harmonization across vendors.Note:
% Siemens, Philip, and GE don't have the line below during data acquisition.

% 2025.07.21: also modify gro generation for Philips, to solve the
% gradient splitting bug. Qingping Chen
if vendor(1) == 'u' || vendor(1) == 'p'
    gro.flatTime = ro_dur + sys.adcDeadTime;
end

adc = mr.makeAdc(N(ax.n1)*ro_os,'Duration',ro_dur,'Delay',gro.riseTime,'system',sys);
groPre = mr.makeTrapezoid(ax.d1,'Area',-gro.amplitude*(adc.dwell*(adc.numSamples/2+0.5)+0.5*gro.riseTime),'system',sys); % the first 0.5 is necessary to acount for the Siemens sampling in the center of the dwell periods
gpe1 = mr.makeTrapezoid(ax.d2,'Area',deltak(ax.n2)*(N(ax.n2)/2),'system',sys); % maximum partition encoding gradient
gpe2 = mr.makeTrapezoid(ax.d3,'Area',-deltak(ax.n3)*(N(ax.n3)/2),'system',sys); % maximum Phase encoding gradient
gslSp = mr.makeTrapezoid(ax.d3,'Area',max(deltak.*N)*4,'Duration',10e-3,'system',sys); % spoil with 4x cycles per voxel
% we cut the RO gradient into two parts for the optimal spoiler timing
if vendor(1) == 'g'
    [gro1, groSp] = mr.splitGradientAt(gro,gro.riseTime+gro.flatTime, 'system', sys) ;
else
    [gro1, groSp] = mr.splitGradientAt(gro,gro.riseTime+gro.flatTime) ;
end
% gradient spoiling
if ro_spoil>0
    groSp=mr.makeExtendedTrapezoidArea(gro.channel,gro.amplitude, 0, gro.amplitude*ro_dur/2*ro_spoil,sys);
end
% calculate timing of the fast loop 
% we will have two blocks in the inner loop:
% 1: spoilers/rewinders + RF 
% 2: prewinder,phase neconding + readout 
[groPre,~,~]=mr.align('right',groPre,gpe1,gpe2); % suboptimal, TODO: fixme
if vendor(1) == 'g'
    adc.delay=gro1.delay+gro.riseTime;
    TRinner = mr.calcDuration(rf_we) + mr.calcDuration(gro1) + mr.calcDuration(groSp) + segmentRingdownTime; % we'll need it for the TI delay
else
    rf_we.delay=mr.calcDuration(groSp, gpe1, gpe2) ;
    gro1.delay=mr.calcDuration(groPre);
    adc.delay=gro1.delay+gro.riseTime;
    gro1=mr.addGradients({gro1,groPre},'system',sys);
    TRinner=mr.calcDuration(rf_we)+mr.calcDuration(gro1); % we'll need it for the TI delay
end
% peSteps -- control reordering
pe1Steps=((0:N(ax.n2)-1)-N(ax.n2)/2)/N(ax.n2)*2; % partition encoding steps
pe2Steps=((0:N(ax.n3)-1)-N(ax.n3)/2)/N(ax.n3)*2; % phase encoding steps

% 2025.07.04: change timing calculation for UIH. Siemens, Philips, and GE
% use the old timings.
% TRinner: doesn't change.
% TIdelay: 0.2320 -> 0.2314 s
% TRoutDelay: 0.5353 -> 0.5359 s
% TE: 0.0037 -> 0.0040 s
% sequence duration: doesn't change
% in conclusion, this timing modification doesn't affect cross-vendor
% harmonization. Qingping Chen

% 2025.07.21: change timing claculation for Philips as well. Siemens and GE
% use the old timings. this minor change doesn't affect cross-vendor
% harmonization. Qingping Chen
% TI calc, from the center of rf180 pulse to the center of rf pulse of the partition encoding = 0 step
% TI = rf180.shape_dur/2+rf180.ringdowntime+TIdelay+find(pe1Steps==0)-1)*TRinner+rf_we.delay+rf_we.shape_dur/2
if vendor(1) == 'u' || vendor(1) == 'p' % On philips and UIH. This calcualtion is more accurate. 2025.07.21. Qingping Chen
    TIdelay=round((TI-...
        (find(pe1Steps==0)-1)*TRinner-...% The duration from the first rf_we to the starting point of the rf_we of Partition encoding = 0 step
        (rf180.shape_dur/2+rf180.ringdownTime)-... % half of the rf180 shape + rf180 ring down time
        rf_we.delay-rf_we.shape_dur/2)...% the delay and shape_dur/2 of rf_we.
        /sys.blockDurationRaster)*sys.blockDurationRaster; % rounding for block duration raster.
    TRoutDelay=TRout-TRinner*N(ax.n2)-TIdelay-mr.calcDuration(rf180) ;
    TE = rf_we.shape_dur/2 + rf_we.ringdownTime + mr.calcDuration(groPre) + adc.numSamples*adc.dwell/2 ;
else % on Siemens and GE
    TIdelay=round((TI-(find(pe1Steps==0)-1)*TRinner-(mr.calcDuration(rf180)-mr.calcRfCenter(rf180)-rf180.delay)-rf_we.delay-mr.calcRfCenter(rf_we))/sys.blockDurationRaster)*sys.blockDurationRaster;
    TRoutDelay=TRout-TRinner*N(ax.n2)-TIdelay-mr.calcDuration(rf180);
    TE = mr.calcDuration(rf_we) - rf_we.shape_dur/2 -rf_we.delay + mr.calcDuration(gro1) - mr.calcDuration(adc)/2 ;
end
ESP = 1000*TRinner ; % echo spacing [ms]
disp(['ADC bandwidth = ', num2str(1/adc.dwell/1000), ' kHz']) ;
disp(['ADC dwell time = ', num2str(adc.dwell*1e6), ' us']) ;
disp(['TE = ', num2str(TE*1000), ' ms;', ' TR = ', num2str(TRout*1000), ' ms;', 'echo spacing = ', num2str(ESP), ' ms']) ;

% all LABELS / counters an flags are automatically initialized to 0 in the beginning, no need to define initial 0's  
% so we will just increment LIN after the ADC event (e.g. during the spoiler)
lblIncPar=mr.makeLabel('INC','PAR', 1) ;
lblResetPar=mr.makeLabel('SET','PAR', 0) ;

% Set PAT scan flag
% Mdh.setPATRefScan; Mdh.setPATRefAndImaScan
lblSetRefScan = mr.makeLabel('SET','REF', true) ;
lblSetRefAndImaScan = mr.makeLabel('SET','IMA', true) ;
lblResetRefScan = mr.makeLabel('SET','REF', false) ;
lblResetRefAndImaScan = mr.makeLabel('SET','IMA', false) ;

% pre-register objects that do not change while looping
gslSp.id=seq.registerGradEvent(gslSp);
groSp.id=seq.registerGradEvent(groSp);
gro1.id=seq.registerGradEvent(gro1);
[~, rf_we.shapeIDs]=seq.registerRfEvent(rf_we); % the phase of the RF object will change, therefore we only pre-register the shapes 
[rf180.id, rf180.shapeIDs]=seq.registerRfEvent(rf180); % 

lblIncPar.id=seq.registerLabelEvent(lblIncPar);
lblResetPar.id=seq.registerLabelEvent(lblResetPar);
lblSetRefScan.id=seq.registerLabelEvent(lblSetRefScan);
lblSetRefAndImaScan.id=seq.registerLabelEvent(lblSetRefAndImaScan);
lblResetRefScan.id=seq.registerLabelEvent(lblResetRefScan);
lblResetRefAndImaScan.id=seq.registerLabelEvent(lblResetRefAndImaScan);

% Carefully set the undersampled region and ACS region (fully sampled central k-space region)
% for GRAPPA reconstruction using ICE on Siemens

% PEsamp indexes the actually sampled lines to the encoded k-space line number. 
% For example, if there were just regular factor 2 undersampling 
% (with no ACS lines), PEsamp would have length 128 and be [1 3 5 ... 255].
% With ACS lines, the elements of PEsamp are separated by 2 near the k-space
% edges, and by 1 in the central ACS region.
nY = N(ax.n3) ;
accelFactorPE = 2 ;
ACSnum = 32 ;
centerLineIdx = floor(nY/2) + 1 ; % index of the center k-space line, starting from 1.
count = 1 ;
clear PEsamp_u ;
for i = 1:nY
    if ( mod(i-centerLineIdx, accelFactorPE)==0 )
        PEsamp_u(count) = i ; % undersampled region
        count = count + 1 ;
    end
end
minPATRefLineIdx = centerLineIdx - ACSnum/2 ; % mininum PAT line starting from 1
maxPATRefLineIdx = centerLineIdx + floor(ACSnum-1)/2 ; % maximum PAT line starting from 1
PEsamp_ACS = minPATRefLineIdx : maxPATRefLineIdx ; % GRAPPA autocalibration lines (ACS region)
PEsamp = union(PEsamp_u, PEsamp_ACS) ; % actually sampled lines
nPEsamp = length(PEsamp) ; % number of actually sampled
PEsamp_INC = diff([PEsamp, PEsamp(end)]) ;

% change orientation to match the product sequence
switch vendor(1)
    case 's' % siemens
        disp('the gradients already match the product sequence on Siemens') ;
    case 'g' % GE
        % convert the polarity of gradients in phase encoding direction
        gpe2 = mr.scaleGrad(gpe2, -1) ;
        gslSp = mr.scaleGrad(gslSp, -1) ;
    case 'u' % United Imaging
        % convert the polarity of gradients in partition (x) and phase encoding (y) direction
        gpe1 = mr.scaleGrad(gpe1, -1) ; % maximum partition encoding gradient
        gpe2 = mr.scaleGrad(gpe2, -1) ; % maximum phase encoding gradient
        gslSp = mr.scaleGrad(gslSp, -1) ;
    case 'p' % Philips
        % convert the polarity of gradients in partition (x) direction
        %gpe1 = mr.scaleGrad(gpe1, -1) ; % maximum partition encoding gradient  % QC: Thomas commented this out 2025.09.01
        % convert the polarity of gradients in readout (z) direction
        %gro1 = mr.scaleGrad(gro1, -1) ;  % QC: Thomas commented this out. 2025.09.01
        %groSp = mr.scaleGrad(groSp, -1) ;  % QC: Thomas commented this out 2025.09.01
end

tic;
% place the noise scan before data acquisition.
if vendor(1) ~= 'g' % if vendor is not GE
    % Add noise scans before data acquisition
    seq.addBlock(adc, mr.makeLabel('SET', 'LIN', 0), mr.makeLabel('SET', 'NOISE', true), lblResetRefAndImaScan, lblResetRefScan) ;
    if vendor(1) == 'p'
        % ThomasR: The first RF follows this ADC too soon for our 7T... So
        % we need some kind of delay! (Either in the block of the ADC, or after)
        seq.addBlock(mr.makeDelay(0.5e-3)) ;
    end
    seq.addBlock(mr.makeLabel('SET', 'NOISE', false)) ;
end

% set line label for the first acquried PE line (may not be 0)
if vendor(1)~='g'
    seq.addBlock(mr.makeLabel('SET', 'LIN', PEsamp(1)-1)) ;
end

for count=1:nPEsamp % outer loop for phase encoding (240 without PAT)
    % set PAT labels for every PE line
    if vendor(1) ~= 'g'
        if ismember(PEsamp(count), PEsamp_ACS)
            if ismember(PEsamp(count), PEsamp_u)
                seq.addBlock(lblSetRefAndImaScan, lblSetRefScan) ;
            else
                seq.addBlock(lblResetRefAndImaScan, lblSetRefScan) ;
            end
        else
            seq.addBlock(lblResetRefAndImaScan, lblResetRefScan) ;
        end
    end
    % 180-deg inversion recovery pulse
    if vendor(1) == 'g'
        seq.addBlock(rf180, mr.makeLabel('SET', 'TRID', 1)) ;
    else
        seq.addBlock(rf180) ;
    end
    seq.addBlock(mr.makeDelay(TIdelay), gslSp) ;
    rf_phase = 0 ;
    rf_inc = 0 ;
    % pre-register the Phase-Encoding gradients (gpe2) that repeat in the inner loop
    gpe2je = mr.scaleGrad(gpe2, pe2Steps(PEsamp(count))) ;
    gpe2je.id = seq.registerGradEvent(gpe2je) ;
    gpe2jr = mr.scaleGrad(gpe2, -pe2Steps(PEsamp(count))) ;
    gpe2jr.id = seq.registerGradEvent(gpe2jr) ;

    for i=1:N(ax.n2)  % inner loop for partition encoding (192)
        rf_we.phaseOffset=rf_phase/180*pi ; % unit: radian
        adc.phaseOffset=rf_phase/180*pi ; % unit: radian
        rf_inc=mod(rf_inc+rfSpoilingInc, 360.0) ; % unit: 1
        rf_phase=mod(rf_phase+rf_inc, 360.0) ; % unit: 1
        %
        if vendor(1) == 'g'
            seq.addBlock(rf_we, mr.makeLabel('SET', 'TRID', 2));
            % x/y/z/ prephasers and readout
            seq.addBlock(groPre, mr.scaleGrad(gpe1, pe1Steps(i)), gpe2je) ;
            seq.addBlock(adc, gro1);
            % y/z rephasers and x spoiler
            seq.addBlock(groSp, mr.scaleGrad(gpe1, -pe1Steps(i)), gpe2jr, lblIncPar) ;
        else
            if (i==1)
                seq.addBlock(rf_we) ; % water-only excitation
            else
                seq.addBlock(rf_we, groSp, mr.scaleGrad(gpe1, -pe1Steps(i-1)), gpe2jr, lblIncPar) ; % after ADC
            end
            seq.addBlock(adc, gro1, mr.scaleGrad(gpe1, pe1Steps(i)), gpe2je) ; % before ADC
        end
    end
    % add rewinder and spoiler gradients without (rf pulse) 
    % after the last readout in the last partition encoding
    if vendor(1) == 'g'
        % extend TR 
        seq.addBlock(gpe1, mr.makeDelay(TRoutDelay), mr.makeLabel('SET', 'TRID', 3));
    else
        seq.addBlock(groSp, mr.scaleGrad(gpe1, -pe1Steps(i)), gpe2jr, ...
            mr.makeDelay(TRoutDelay), mr.makeLabel('INC','LIN', PEsamp_INC(count)), lblResetPar) ;
    end
end

if vendor(1) == 'g' % if vendor is GE
    % Add noise scans after data acqusition on GE scanners
    seq.addBlock(mr.makeDelay(5), mr.makeLabel('SET', 'TRID', 4)) ; % sec
    % seq.addBlock(adc, mr.makeLabel('SET', 'LIN', 0), mr.makeLabel('SET', 'PAR', 0), mr.makeLabel('SET', 'NOISE', true), lblResetRefAndImaScan, lblResetRefScan) ;
    seq.addBlock(adc, mr.makeDelay(1));
    % seq.addBlock(mr.makeLabel('SET', 'NOISE', false)) ;
end

fprintf('Sequence ready (blocks generation took %g seconds)\n', toc);

%% check whether the timing of the sequence is correct
[ok, error_report]=seq.checkTiming;

if (ok)
    fprintf('Timing check passed successfully\n');
else
    fprintf('Timing check failed! Error listing follows:\n');
    fprintf([error_report{:}]);
    fprintf('\n');
end

%% plot, etc
seq.plot('TimeRange',[TRout*0 TRout*1], 'stacked', 1, 'showBlocks', 1) ;


%% evaluate label settings more specifically
%seq.plot('timeRange', [0 32]*TRout, 'TimeDisp', 'ms', 'Label', 'LIN');
adc_lbl=seq.evalLabels('evolution','adc');
if vendor(1) ~= 'g'
    figure; plot(adc_lbl.REF);
    hold on; plot(adc_lbl.LIN);plot(adc_lbl.NOISE);
    plot(adc_lbl.IMA) ;plot(adc_lbl.PAR) ;
    legend('REF','LIN', 'NOISE','IMA','PAR');
    title('evolution of labels/counters');
end
%%
seq.setDefinition('FOV', fov) ;
if vendor(1) == 'u'
	seq.setDefinition('Dimension', 3);
	seq.setDefinition('SliceThickness', 1e-3);
end
seq.setDefinition('Name', 'we_mp') ;
seq.setDefinition('ReadoutOversamplingFactor', ro_os) ;
seq.setDefinition('OrientationMapping', 'SAG') ; % only when programming in saggital orientation
seq.setDefinition('kSpaceCenterLine', centerLineIdx-1) ;
seq.setDefinition('PhaseResolution', phaseResoluion) ;
seq.setDefinition('ReceiverGainHigh',1) ;
seq.write('mprage_challenge.seq') ;      % Write to pulseq file

return;

%% visualize the 3D k-space (only makes sense for low-res, otherwise one sees nothing)
%if Nx<=32
    tic;
    [kfa,ta,kf]=seq.calculateKspacePP();
    toc
    figure;plot3(kf(1,:),kf(2,:),kf(3,:));
    hold on;plot3(kfa(1,:),kfa(2,:),kfa(3,:),'r.');
%end



%% very optional slow step, but useful for testing during development e.g. for the real TE, TR or for staying within slew rate limits  

rep = seq.testReport; 
fprintf([rep{:}]); 
